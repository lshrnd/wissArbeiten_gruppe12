ini.tape.2 <- c("b", "0", "1", "0", "1", "1", "b")
ini.tape.3 <- c("b", "1", "1", "1", "0", "0", "b")
ini.tape.4 <- c("b", "0", "1", "b")
ini.tape.5 <- c("b", "1", "1", "1", "b")
ini.tape.6 <- c("b", "0", "b")
ini.tape.7 <- c("b", sample(c(0, 1), 20, replace = TRUE), "b")
runTuringMachine(prog.sort, tape = ini.tape.1, L0 = 1L, F = 0, ini.pos = 1L)
runTuringMachine(prog.sort, tape = ini.tape.2, L0 = 1L, F = 0, ini.pos = 1L)
runTuringMachine(prog.sort, tape = ini.tape.3, L0 = 1L, F = 0, ini.pos = 1L)
runTuringMachine(prog.sort, tape = ini.tape.4, L0 = 1L, F = 0, ini.pos = 1L)
runTuringMachine(prog.sort, tape = ini.tape.5, L0 = 1L, F = 0, ini.pos = 1L)
runTuringMachine(prog.sort, tape = ini.tape.6, L0 = 1L, F = 0, ini.pos = 1L)
runTuringMachine(prog.sort, tape = ini.tape.7, L0 = 1L, F = 0, ini.pos = 1L)
sample(0:9, 1, replacement = FALSE)
sample(0:9, 1)
sample(0:9, 1)
sample(0:9, 1)
sample(0:9, 1)
sample(10:11)
sample(0:9)
sample.int(99, 1)
sample(1000:9999, 1)
source("~/.active-rstudio-document")
save(results, file = "results_test.RData")>
tictoc:toc()
tictoc::tic()
save(results, file = "results_test.RData")
# Stichprobengroesse n
n <- 1000
# Wiederholungen N
N <- 10000
# Argumente
mu <- 0
sigma <- 1
set.seed(1234) # zur Replizierbarkeit der Ergebnisse
data <- replicate(N, rnorm(n, mu, sigma))
str(data)
means <- apply(data, 2, mean)
mean_mse <- mean((means - mu)^2)
mean_bias <- mean(means - mu)
medians <- apply(data, 2, median)
median_mse <- mean((medians - mu)^2)
median_bias <- mean(medians - mu)
results <- list(
"wahre Parameter" = c("mu" = mu, "sigma" = sigma),
"Stichprobengroesse" = c("n" = n),
"Schaetzungen" = matrix(c(means, medians), ncol = 2, nrow = N, byrow = F,
dimnames = list(1:N, c("mean", "median"))),
"MSE und bias von arith. Mittel" = c("MSE" = mean_mse, "bias" = mean_bias),
"MSE und bias von Median" = c("MSE" = median_mse, "bias" = median_bias)
)
str(results)
save(results, file = "results_test.RData")
tic("total")
library(tictoc)
library(rbenchmark)
# Stichprobengroesse n
n <- 1000
library("rbenchmark")
print(microbenchmark(test()))
library(microbenchmark)
test <- function() {
# Stichprobengroesse n
n <- 1000
# Wiederholungen N
N <- 10000
# Argumente
mu <- 0
sigma <- 1
set.seed(1234) # zur Replizierbarkeit der Ergebnisse
data <- replicate(N, rnorm(n, mu, sigma))
str(data)
means <- apply(data, 2, mean)
mean_mse <- mean((means - mu)^2)
mean_bias <- mean(means - mu)
medians <- apply(data, 2, median)
median_mse <- mean((medians - mu)^2)
median_bias <- mean(medians - mu)
results <- list(
"wahre Parameter" = c("mu" = mu, "sigma" = sigma),
"Stichprobengroesse" = c("n" = n),
"Schaetzungen" = matrix(c(means, medians), ncol = 2, nrow = N, byrow = F,
dimnames = list(1:N, c("mean", "median"))),
"MSE und bias von arith. Mittel" = c("MSE" = mean_mse, "bias" = mean_bias),
"MSE und bias von Median" = c("MSE" = median_mse, "bias" = median_bias)
)
str(results)
save(results, file = "results_test.RData")
}
print(microbenchmark(test()))
stop
stop()
library(microbenchmark)
test <- function() {
# Stichprobengroesse n
n <- 1000
# Wiederholungen N
N <- 10000
# Argumente
mu <- 0
sigma <- 1
set.seed(1234) # zur Replizierbarkeit der Ergebnisse
data <- replicate(N, rnorm(n, mu, sigma))
str(data)
means <- apply(data, 2, mean)
mean_mse <- mean((means - mu)^2)
mean_bias <- mean(means - mu)
medians <- apply(data, 2, median)
median_mse <- mean((medians - mu)^2)
median_bias <- mean(medians - mu)
results <- list(
"wahre Parameter" = c("mu" = mu, "sigma" = sigma),
"Stichprobengroesse" = c("n" = n),
"Schaetzungen" = matrix(c(means, medians), ncol = 2, nrow = N, byrow = F,
dimnames = list(1:N, c("mean", "median"))),
"MSE und bias von arith. Mittel" = c("MSE" = mean_mse, "bias" = mean_bias),
"MSE und bias von Median" = c("MSE" = median_mse, "bias" = median_bias)
)
str(results)
save(results, file = "results_test.RData")
}
x <- microbenchmark(test())
library(microbenchmark)
#test <- function() {
# Stichprobengroesse n
n <- 1000
# Wiederholungen N
N <- 10000
# Argumente
mu <- 0
sigma <- 1
set.seed(1234) # zur Replizierbarkeit der Ergebnisse
data <- replicate(N, rnorm(n, mu, sigma))
str(data)
means <- apply(data, 2, mean)
mean_mse <- mean((means - mu)^2)
mean_bias <- mean(means - mu)
medians <- apply(data, 2, median)
median_mse <- mean((medians - mu)^2)
median_bias <- mean(medians - mu)
results <- list(
"wahre Parameter" = c("mu" = mu, "sigma" = sigma),
"Stichprobengroesse" = c("n" = n),
"Schaetzungen" = matrix(c(means, medians), ncol = 2, nrow = N, byrow = F,
dimnames = list(1:N, c("mean", "median"))),
"MSE und bias von arith. Mittel" = c("MSE" = mean_mse, "bias" = mean_bias),
"MSE und bias von Median" = c("MSE" = median_mse, "bias" = median_bias)
)
str(results)
save(results, file = "results_test.RData")
#}
#x <- microbenchmark(test())
#Uebungsblatt 1
#Jorrit Kuehne
library(microbenchmark)
#Aufgabe 1
#Funktion ggt   - Setzt den euklidischen Algorithmus rekursiv um und berechnet
#                 so den groessten gemeinsamen Teiler von x, y.
#Input:   x, y  - Ganzzahlige Skalare, von denen der ggt berechnet wird (y=/=0)
#Return:  r     - Der berechnete Rest des letzten rekursiven Aufrufs wird als
#                 ggt zurueckgegeben
ggt <- function(x, y) {
stopifnot(is.numeric(x), is.numeric(y))
if((r <- x %% y) == 0)
return(abs(y))
else
ggt(y, r)
}
#Funktion testGgt - Testet die Funktion ggt an vorgegebenen und selbstgewaehlten
#                   Beispielen, indem ggt(x, y) aufgerufen und mit dem
#                   erwarteten Ergebnis verglichen wird.
#Output           - Gibt die Funktion TRUE aus, so waren alle Tests erfolgreich.
testGgt <- function() {
ggt(0, 1) == 1 #Wurde gewaehlt um zu testen, ob es mit 0 funktioniert
ggt(1, 2) == 1
ggt(26, 34) == 2
ggt(58, 145) == 29
ggt(1000001, 1048576) == 1 #Beispiel mit grossen Zahlen
ggt(34,26) == 2 #Beispiele von oben, mit vertauschten Zahlen
ggt(145, 58) == 29
ggt(-20,-15) == 5 #Beispiel mit negativen Zahlen
ggt(10000000000001,5) == 1  #Beispiel mit einer grossen & einer kleinen Zahl
}
testGgt()
#TODO: wieso diese beispiele? Andere gute Beispiele
#Aufgabe 3
#a)
#Funktion power1  - Berechnet x^n iterativ, indem x n mal mit sich selbst
#                   multipliziert wird
#Input:   x       - Reellwertiger Skalar
#         n       - Ganzzahliger Skalar
#Output:  erg     - Reelwertiger Skalar, Ergebnis von x^n
power1 <- function(x, n) {
stopifnot(is.numeric(x), is.numeric(n))
erg <- 1
while(n>0) {
erg <- erg * x
n <- n - 1
}
return(erg)
}
#b)
#Funktion power2  - Berechnet x^n iterativ mithilfe Binaerer Exponentation, d.h.
#                   der Exponent wird solange durch 2 geteilt wie moeglich und
#                   jedes Mal wird dann x mit sich selbst multipliziert bis n
#                   nicht mehr durch 2 teilbar ist und man das Ergebnis erhaelt.
#Input:   x       - Reellwertiger Skalar
#         n       - Ganzzahliger Skalar
#Output:  ergList - Zweielementige Liste der Ergebnisse, enthaelt:
#                   erg   - Ergebnis von x^n
#                   count - Anzahl der gesamten Multiplikationen
power2 <- function(x, n) {
stopifnot(is.numeric(x), is.numeric(n))
erg <- 1
count <- 0
while(n > 0) {
#Falls n nicht (mehr) ganzzahlig durch 2 teilbar, muss x einmal zusätzlich
#multipliziert werden
if(n %% 2 == 1) {
erg <- erg * x
count <- count + 1
}
if(n > 1) {
y <- x
x <- x * y
count <- count + 1
}
n <- n %/% 2
}
return(ergList <- list("Ergebnis" = erg, "Count" = count))
}
#c)
#Funktion power3  - Berechnet x^n mit der in R enthaltenen Basisfunktion
#Input:   x       - Reellwertiger Skalar
#         n       - Ganzzahliger Skalar
#Output:          - Gibt mit x^n Ergebnis der Basisfunktion zurueck
power3 <- function(x, n){
stopifnot(is.numeric(x), is.numeric(n))
return(x^n)
}
#Funktion testPowers  - Dient dazu mit microbenchmark die Laufzeiten von power1,
#                       power2 und power3 zu messen und zu vergleichen.
testPowers <- function() {
print(microbenchmark(power1(2,10)))
print(microbenchmark(power2(2,10)))
print(microbenchmark(power3(2,10)))
cat("\n")
print(microbenchmark(power1(3.5,8)))
print(microbenchmark(power2(3.5,8)))
print(microbenchmark(power3(3.5,8)))
cat("\n")
print(microbenchmark(power1(-4,13)))
print(microbenchmark(power2(-4,13)))
print(microbenchmark(power3(-4,13)))
cat("\n")
print(microbenchmark(power1(45,7)))
print(microbenchmark(power2(45,7)))
print(microbenchmark(power3(45,7)))
cat("\n")
print(microbenchmark(power1(123.85,7)))
print(microbenchmark(power2(123.85,7)))
print(microbenchmark(power3(123.85,7)))
cat("\n")
print(microbenchmark(power1(123.85,19)))
print(microbenchmark(power2(123.85,19)))
print(microbenchmark(power3(123.85,19)))
cat("\n")
print(microbenchmark(power1(123.85,35)))
print(microbenchmark(power2(123.85,35)))
print(microbenchmark(power3(123.85,35)))
cat("\n")
print(microbenchmark(power1(325,74)))
print(microbenchmark(power2(325,74)))
print(microbenchmark(power3(325,74)))
}
testPowers()
#Beobachtungen von testPowers:
#
#Der Test der power-Funktionen ergibt ein von allen gewaehlten Beispielen
#bestaetigtes Ergebnis.
#Die power3 Funktion ist, mit im Mittel ca. 600ns die schnellste.
#Bei kleineren Zahlenwerten ist sie etwa doppelt so schnell, wie die power1
#Funktion und etwa fünf mal so schnell, wie die power2 Funktion.
#Werden die Zahlenwerte jedoch betragsmaessig groesser, so steigt die Laufzeit
#der Funktionen power1 und power2 massgeblich an, waehrend sich bei der power3
#Funktion kaum eine Veraenderung feststellen laesst.
View(oneStep)
clear
clearPushBack()
rm
rm(list = ls())
load("data_students.csv")
load("data_students.csv")
load("data_students")
load(data_students.csv)
read.csv(data_students.csv)
read.csv("data_students.csv")
read.csv("E:\Documents\TU Dortmund\2022_23 WiSe\Module\Wiss. Arbeiten\GitHub")
read.csv("E:/Documents/TU Dortmund/2022_23 WiSe/Module/Wiss. Arbeiten/GitHub/data_students.csv")
dataset <- read.csv("E:/Documents/TU Dortmund/2022_23 WiSe/Module/Wiss. Arbeiten/GitHub/data_students.csv")
dataset(5)
dataset[3]
dataset[1]
#(a) decsriptMetric
#Short:   Funktion zur Deskription metrischer Variablen
#Input:   ?
#Output:  ?
#Funktionsweise:  ?
descriptMetric <- function() {
#TODO
}
descriptMetric(dataset[1])
#(a) decsriptMetric
#Short:   Funktion zur Deskription metrischer Variablen
#Input:   ?
#Output:  ?
#Funktionsweise:  ?
descriptMetric <- function(metricV) {
#TODO
mean(metricV)
}
dataset[1]
descriptMetric(dataset[1])
x <- dataset[1]
descriptMetric(x)
x <- c(dataset[1])
descriptMetric(x)
x
typeof(x)
y <- dataset[3]
x <- dataset[1]
descriptMetric(x)
z <- c(1:10)
descriptMetric(z)
#Datensatz laden
dataset = read.csv("data_students.csv")
#Datensatz laden
setwd("F:\Git\Repositories\wissArbeiten_gruppe12"")
#Datensatz laden
setwd("F:/Git/Repositories/wissArbeiten_gruppe12"")
dataset
dataset = read.csv("data_students.csv")
#Datensatz laden
setwd("F:/Git/Repositories/wissArbeiten_gruppe12")
dataset = read.csv("data_students.csv")
dataset
#Daten in einzelne Vektoren "entpacken"
alter    <- unlist(dataset[1])
fach     <- unlist(dataset[2])
intMathe <- unlist(dataset[3])
intInfo  <- unlist(dataset[4])
matheLK  <- unlist(dataset[5])
#(a) descriptMetric
#Short:     Berechnet verschiedene Lage- und Streuungsmasse einer metrischen
#           Variablen und gibt diese aus.
#Input:     metricV - eine metrische Variable (als Vektor)
#Output:    Mittelwert, Median, Standardabweichung, Minimum, Maximum, Modus
#Funktion:  Berechnet mit Standardfunktionen in R Mittelwert, Median, Standard-
#           abweichung, Minimum, Maximum und mit helper_functions Modus und gibt
#           Ergebnisse aus.
descriptMetric <- function(metricV, name) {
cat(name, "\n")
cat("Lage- und Streuungsmasse: \n")
cat("Mittelwert:", mean(metricV),"\n")
cat("Median: ", median(metricV),"\n")
cat("Modus: ", modus(metricV), "\n")
cat("Standardabweichung: ", sd(metricV),"\n")
cat("Kleinster Wert: ", min(metricV), "\n")
cat("Groesster Wert: ", max(metricV), "\n")
cat("\n")
}
#(b) descriptCategoric
#Short:     Berechnet absolute u. relative Haeufigkeiten einer kategoriellen
#           Variable und gibt diese aus.
#Input:     c1 - kategorielle Variable; name - Name der Variablen
#Output:    Absolute & Relative Haeufigkeitstabelle
#Funktion:  Nutzt Standardfunktionen um Haeufigkeitstabellen zu berechnen und
#           auszugeben
descriptCategoric <- function(c1, name) {
cat("Haeufigkeitstabellen", name, "\n")
print("Absolute Haeufigkeitstabelle")
print(table(c1))
print("Relative Haeufigkeitstabelle")
print(table(c1)/length(c1))
}
#(c) descriptBiCategoric
#Short:     Funktion zur Deskription zweier kategorialer Variablen
#Input:     c1, c2 - katetegoriale Variablen (als Vektoren)
#Output:    Haeufigkeitstabellen (absolut/relativ);
#           Cramers- und Pearson-Kontingenzindex
#Funktion:  Haeufigkeitstabllen mit Standardfunktionen; Kontingenzindizes mit
#           library DescTools
descriptBiCategoric <- function(c1, c2, name1, name2) {
hTable <- table(c1, c2)
cat("c1 = ", name1, "; c2 = ", name2, "\n")
cat("Absolute Haeufigkeitstabelle: \n")
print(hTable)
cat("\n Relative Haeufigkeitstabelle: \n")
print(prop.table(hTable))
cat("Cramers Kontingenzindex: ", CramerV(c1, c2), "\n")
cat("Pearson Kontingenzindex: ", ContCoef(c1, c2), "\n")
}
#(d) descriptBiMetricBinary
#Short:     Funktion zur Deskription einer metrischen und einer binaeren Variable
#Input:     m - metrische Variable (Vektor); b - dichotome Variable (Vektor)
#Output:    Absolute Haeufigkeitstabelle; Lage- und Streuungsmaße der metrischen
#           Variablen, nach Aufteilung anhand der binaeren Variablen
#Funktion:  Häufigkeitstabelle Standardfunktionen; Aufteilung (siehe
#            Funktionen-R-Skript-2.R; Deskription siehe descriptMetric
descriptBiMetricBinary <- function(m, b, nameM, nameB) {
hTable <- table(m, b)
cat("m = ", nameM, "; b = ", nameB, "\n")
cat("Absolute Häufigkeitstabelle:")
print(hTable)
cat("\n")
splitted <- split(m, b, length = length(m))
b0 <- splitted[[1]]
b1 <- splitted[[2]]
descriptMetric(b0, name = c(nameM, "ohne", nameB, ":"))
descriptMetric(b1, name = c(nameM, "mit", nameB, ":"))
}
#(f) visualizeCategoic
#Short:     Erstellt Balkendiagramm faer eine kategorische Variable
#Input:     c1 - kategoriale Variable (Vektor); Rest selbsterklaerend
#Output:    Balkendiagramm (mit absoluten Haeufigkeiten)
#Funktion:  Erstellt Balkendiagramm mit Standardfunktion
visualizeCategoric <- function(c1, ymin, ymax, title, ylabel, xlabel) {
barplot(table(c1), ylim = c(ymin, ymax), main = title, xlab = xlabel,
ylab = ylabel)
}
#(g) visualizeBiCategoic
#Short:     Funktion die fuer zwei kategoriale Variablen einen Mosaikplot erstellt
#Input:     c1, c2 - kategoriale Variablen (Vektoren); Rest selbsterklaerend
#Output:    Mosaikplot (c1 auf x-Achse, c2 auf y-Achse)
#Funktion:  Erstellt Mosaikplot mit Standardfunktion
visualizeBiCategoric <- function(c1, c2, title, xlabel, ylabel) {
mosaicplot(c1~c2, main = title, xlab = xlabel, ylab = ylabel)
}
#(h1) modus
#Short:     Berechnet den Modus einer Variablen
#Input:     x - Variable (als Vektor)
#Output:    Der/die haeufigste/n Wert/e
#Funktion:  #TODO
modus <- function(x) {
u <- unique(x)
tab <- tabulate(match(x, u))
u[tab == max(tab)]
}
#(h2) split
#Short:     Teilt einen Vektor in zwei Vektoren, anhand eines anderen Vektors mit
#           den Werten 0,1; findet in (d) Anwendung
#Input:     toSplit - aufzuteilender Vektor;
#           splitOn - Vektor mit Aufteilungsgrundlage
#Output:    Eine Liste mit den beiden Ergebnisvektoren
#Funktion:  Erzeugt zwei Vektoren und fügt diesen Elemente aus toSplit hinzu,
#           abhaengig davon, welcher Wert am gleichen Index in splitOn steht.
split <- function(toSplit, splitOn, length) {
len <- c(1:length)
part1 <- vector(mode = "numeric")
part2 <- vector(mode = "numeric")
for(j in len) {
if(splitOn[j] == 0) {
part1 <- append(part1, toSplit[j])
} else {
part2 <- append(part2, toSplit[j])
}
}
return(splitVec <- list(part1, part2))
}
#Auswertung
descriptMetric(alter, name = "Alter")
descriptCategoric(fach, "Studienfach")
visualizeCategoric(fach, title = "Studienfach")
visualizeCategoric(fach, title = "Studienfach", ymin = 0, ymax = 40, xlabel = "Studienfach", ylabel = "test")
visualizeCategoric(fach, title = "Studienfach", ymin = 0, ymax = 40, xlabel = "Studienfach", ylabel = "abs. Hauefigkeit")
descriptCategoric(intMathe, "Interesse an Mathe")
visualizeCategoric(intMathe, title = "Balkendiagramm Interesse an Mathe",
ymax = 35, ylabel = "Interesse an Mathe", xlabel = "abs. Häufigkeit")
#(f) visualizeCategoic
#Short:     Erstellt Balkendiagramm faer eine kategorische Variable
#Input:     c1 - kategoriale Variable (Vektor); Rest selbsterklaerend
#Output:    Balkendiagramm (mit absoluten Haeufigkeiten)
#Funktion:  Erstellt Balkendiagramm mit Standardfunktion
visualizeCategoric <- function(c1, ymin = 0, ymax, title, ylabel, xlabel) {
barplot(table(c1), ylim = c(ymin, ymax), main = title, xlab = xlabel,
ylab = ylabel)
}
visualizeCategoric(intMathe, title = "Balkendiagramm Interesse an Mathe",
ymax = 35, ylabel = "Interesse an Mathe", xlabel = "abs. Häufigkeit")
#Interesse an Informatik
descriptCategoric(intInfo, "Interesse an Info")
visualizeCategoric(intInfo, title = "Balkendiagramm Interesse an Info",
ymax = 25, ylabel = "Interesse an Info", xlabel = "abs. Häufigkeit")
#Mathe LK
descriptCategoric(matheLK, "Mathe LK")
visualizeCategoric(matheLK, title = "Balkendiagramm Mathe LK",
ymax = 25, xlabel = "Mathe LK", ylabel = "abs. Häufigkeit")
visualizeCategoric(matheLK, title = "Balkendiagramm Mathe LK",
ymax = 75, xlabel = "Mathe LK", ylabel = "abs. Häufigkeit")
visualizeCategoric(intMathe, title = "Balkendiagramm Interesse an Mathe",
ymax = 35, xlabel = "Interesse an Mathe", ylabel = "abs. Häufigkeit")
visualizeCategoric(intInfo, title = "Balkendiagramm Interesse an Info",
ymax = 25, xlabel = "Interesse an Info", ylabel = "abs. Häufigkeit")
visualizeCategoric(matheLK, title = "Balkendiagramm Mathe LK",
ymax = 75, xlabel = "Mathe LK", ylabel = "abs. Häufigkeit")
visualizeCategoric(matheLK, title = "Balkendiagramm Mathe LK",
ymax = 75, xlabel = "Mathe LK", ylabel = "abs. Häufigkeit")
visualizeCategoric(matheLK, title = "Balkendiagramm Mathe LK",
ymax = 80, xlabel = "Mathe LK", ylabel = "abs. Häufigkeit")
#Untersuche auf moegliche Abhaengigkeiten zweier Variablen:
#Alter und Mathe LK
descriptBiMetricBinary(alter, matheLK, "Alter", "Mathe LK")
